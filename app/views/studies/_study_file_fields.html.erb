<div class="well well-sm">
	<%= form_for(study_file, url: update_study_file_study_path(@study._id), html: {class: 'upload-form', id: study_file._id, remote: true}) do |f| %>
		<%= f.hidden_field :study_id, value: params[:id] %>
		<div class="form-group row">
			<div class="col-sm-4">
				<%= f.label :name %><br />
				<%= f.text_field :name, class: 'form-control filename', readonly: !f.object.human_data?, placeholder: 'Filename is taken from uploaded file...' %>
			</div>
			<div class="col-sm-8">
				<%= f.label :description %><br />
				<%= f.text_field :description, class: 'form-control' %>
			</div>
		</div>
		<div class="form-group row">
			<div class="col-sm-4">
				<%= f.label :file_type %><br />
				<%= f.select :file_type, options_for_select(StudyFile::STUDY_FILE_TYPES, f.object.file_type), {}, {class: 'form-control filetype'} %>
			</div>
			<div class="col-sm-5 upload-field <%= study_file.human_data? ? 'hidden' : nil %>">
				<%= f.label :upload, 'Upload Data File' %><br />
				<%= f.file_field :upload, class: 'btn btn-default fileinput-button' %>
				<%= f.hidden_field :status, value: 'uploading' %>
			</div>
			<div class="col-sm-5 fastq-field <%= study_file.human_data? ? nil : 'hidden' %>">
				<%= f.label :human_fastq_url, 'Link to primary human fastq file' %><br />
				<%= f.text_field :human_fastq_url, class: 'form-control', disabled: !f.object.human_data? %>
				<%= f.hidden_field :human_data, value: f.object.human_data %>
			</div>
			<div class="col-sm-3">
				<%= f.label :actions %>
				<div class="row">
					<div class="col-xs-6">
						<%= f.submit 'Update', class: 'btn btn-success btn-block save-study-file' %>
					</div>
					<div class="col-xs-6">
						<%= link_to 'Delete', delete_study_file_study_path(@study._id, study_file._id), method: :delete, class: 'btn btn-block btn-danger', data: {remote: true, confirm: 'Are you sure? This cannot be undone.'} %>
					</div>
				</div>
			</div>
			<div class="col-sm-12">
				<span class="help-block help-text"><%=  f.object.file_type.nil? ? required_help_text[StudyFile::STUDY_FILE_TYPES.first].html_safe : required_help_text[f.object.file_type].html_safe %></span>
			</div>
		</div>
		<% if study_file.upload_file_name.nil? %>
			<div class="form-group" class="upload-progress">
				<table class="table table-condensed">
					<tbody class="files"></tbody>
				</table>
			</div>
		<% end %>

	<% end %>

	<% if study_file.parsed? || (!study_file.parseable? && study_file.upload.exists?) || study_file.human_data? %>
		<p><label>Link to file </label><br /><%= render partial: '/layouts/download_link', locals: {study: @study, study_file: study_file} %></p>
	<% elsif study_file.file_type == 'Cluster Coordinates' && @study.can_parse_clusters %>
		<%= render 'parse_cluster_form', study_file: study_file %>
	<% elsif study_file.file_type == 'Cluster Coordinates' && !@study.can_parse_clusters %>
		<div class="bs-callout bs-callout-danger">
			<h4>Cannot parse file yet</h4>
			<p><%= render partial: '/layouts/download_link', locals: {study: @study, study_file: study_file} %> <%= render partial: 'refresh_link', locals: {study_file: study_file} %></p>
			<p class="help-block">In order to parse cluster coordinates, you must first upload a <strong>cluster assignments file</strong>.  Once you have done so, click 'refresh' to load the parsing form.</p>
		</div>
	<% elsif study_file.file_type == 'Expression Matrix' %>
		<%= render 'parse_expression_form', study_file: study_file %>
	<% elsif study_file.file_type == 'Marker Gene List' %>
		<%= render 'parse_precomputed_form', study_file: study_file %>
	<% end %>

</div>
<script type="text/javascript">

	$(document).ready(function() {
		var resume_path = "<%= resume_upload_study_path %>";
		var update_status_path = "<%= update_status_study_path %>";
		var result_path = "<%= retrieve_upload_study_path(@study._id) %>";
		var uploader = "#<%= study_file._id %>";
		var fileType = $(uploader).find('.filetype').val();

		// disable save button if this is a new record
		$(uploader).find('.save-study-file').attr('disabled', $(uploader).find('.filename').val() == '');
		// attach fileupload plugin and callbacks
		$(uploader).fileupload({
			url: "<%= upload_study_path(@study._id) %>",
			maxChunkSize: 10000000, // 10 MB
			type: 'PATCH',
			acceptFileTypes: setAcceptedFiletypes(fileType),
			add: function (e, data) {
				var that = this;
				var fileName = data.files[0].name.replace(/ /g, '_');
				var ext = fileName.split('.').slice(-1)[0];
				// validates non-human fastq, will change to text field if user is linking to human data
				if (ext == 'fq' || ext == 'fastq') {
					$('#study-files-notice-target').html("<%= escape_javascript(render partial: 'fastq_modal', locals: {target: study_file._id}) %>");
				}
				// this is the chunked upload callback, will upload 10MB at a time until finished
				$.getJSON(resume_path, { file: fileName }, function (result) {
						var file = result.file;
						data.uploadedBytes = file && file.size;
						$.blueimp.fileupload.prototype.options.add.call(that, e, data);
				});
			},
			// on each chunk completion, update status
			chunkdone: function(e, data) {
				var perc = parseInt(data.loaded / data.total * 100, 10);
				$(data.context).find('h1').html(perc + "%");
			},
			// file upload is done, now clean up
			done: function(e, data) {
				var fileName = data.files[0].name.replace(/ /g, '_');
				// update upload status
				$.ajax({
					url: update_status_path,
					type: "PATCH",
					data: { status: 'uploaded', file: fileName}
				});
				// replace form with updated values, as IDs may have incremented
				$.get(result_path, {file: fileName, selector: uploader});
			}
		});

		// add confirm dialog when user selects fastq file
		// also change help text
		$(uploader).find('.filetype').change(function(e) {
			var selected = $(e.target).val();
			var helpText = <%= raw required_help_text.to_json %>;
			var helpTarget = $(uploader).find('span.help-text');
			// reinit the tooltip
			console.log('Changing help text to: ' + selected + ' for ' + uploader);
			$(helpTarget).html(helpText[selected]).effect('highlight', 500);

			if ( selected == 'Fastq' ) {
				$('#study-files-notice-target').html("<%= escape_javascript(render partial: 'fastq_modal', locals: {target: study_file._id}) %>");;
			} else {
				if ($(uploader).find('.upload-field').css('display') == 'none' ) {
					console.log('Toggling Fastq fields for ' + uploader);
					toggleFastqFields("<%= study_file._id %>");
				}
			}
			var allowedTypes = setAcceptedFiletypes(selected);
			// reset allowed filetypes
			$(uploader).fileupload('option', 'acceptFileTypes', allowedTypes);
		});

		// re-enable tooltips
		$('[data-toggle="tooltip"]').tooltip({container: 'body'});

		// reattach click listener to download a file when private, will open modal for timed HTML5 download
		$(uploader).find('.download-btn').click(function() {
			var url = $(this).data('filepath');
			$.get(url);
		});

		// start small spinner on loading functions
		$(uploader).find('.loading').click(function() {
			var tgt = $(this).parent()[0];
			new Spinner(smallOpts).spin(tgt);
		});

	});

</script>